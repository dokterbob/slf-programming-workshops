#!/usr/bin/python

#------------------------------------------------------------------------
# this is an example evaluation script for a bunch of data files
# containing the typical steps required to get out some numbers
#------------------------------------------------------------------------

#------------------------------------------------------------------------
# the following import commands are a mixture of "include" 
# directives in c, combined with "using namespace" directives in c++
#------------------------------------------------------------------------
import glob
import sys
import numpy as np # numerical python stuff
import matplotlib.pyplot as plt
import pylab as pl 
from matplotlib.ticker import MultipleLocator, FormatStrFormatter
from matplotlib.gridspec import GridSpec




#print some message on the screen
print "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
print "%"
print "% This is an example data evaluation script in python\n"
print "%"
print "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"

colors = ('b', 'g', 'r', 'c', 'm', 'y', 'k')

#------------------------------------------------------------------------
# open data file which contains, e.g. a list of tomography files
#------------------------------------------------------------------------
evalfiles=glob.glob("./*.out")

#set font size tick labels
pl.rc('xtick', labelsize=24) 
pl.rc('ytick', labelsize=24)

# instantiate figure 1
fig1 = plt.figure(figsize=(16,10))
gs = GridSpec(3, 3)
gs.update(left=0.1, right=0.45, wspace=0.1, hspace=0.6)
ax1 = plt.subplot(gs[0, :])
ax2 = plt.subplot(gs[1, :])
ax3 = plt.subplot(gs[-1, :])
gs = GridSpec(2, 2)
gs.update(left=0.55, right=0.9, wspace=0.1, hspace=0.6)
ax9 = plt.subplot(gs[0, :])
ax10 = plt.subplot(gs[-1, :])



# Expliciete namen voor variabeles schelen jouw (later) en je collega's nu
# bergen koppijn. Maakt je code leesbaarder.

# Verder: dit hoef je denk ik maar 1x te doen
#figure_manager = plt.get_current_fig_manager()

# Dit laat een venster zien - ik vermoed dat dat je bedoeling is.
# Ik zou in de handleiding van matplotlib even uitzoeken waar geometry
# tegenwoordig zit.

# Vermoedelijk doe je figure_manager.resize(<iets>) en daarna figure_manager.show()
#figure_manager.show()

# Note: dit is een commando wat waarschijnlijk werkt op een archaische versie
# van matplotlib
# figure_manager.window.geometry("+0+0")

# instantiate figure 2
fig2 = plt.figure()
ax4 = fig2.add_subplot(1,1,1)
 

#plt.get_current_fig_manager().window.geometry("+0+200")
#figure_manager = plt.get_current_fig_manager()
#figure_manager.show()

# instantiate figure 3
fig3 = plt.figure()
ax5 = fig3.add_subplot(1,1,1)

fig4 = plt.figure()
ax6 = fig4.add_subplot(1,1,1)





# plt.get_current_fig_manager().window.geometry("+0+400")
#figure_manager = pl.get_current_fig_manager()
#figure_manager.show()

# instantiate some result arrays
iceresultx_mean = np.zeros((len(evalfiles),1))
iceresulty_mean = np.zeros((len(evalfiles),1))
iceresultz_mean = np.zeros((len(evalfiles),1))
poreresultx_mean = np.zeros((len(evalfiles),1))
poreresulty_mean = np.zeros((len(evalfiles),1))
poreresultz_mean= np.zeros((len(evalfiles),1))
#------------------------------------------------------------------------
# main loop over result files: evaluate something, plots, BTW: the
# body of the loop is controlled by indentation
# ------------------------------------------------------------------------
for n_files in range(len(evalfiles)):
    #read data
    data=np.loadtxt(evalfiles[n_files], comments='#', delimiter="\t")
    #print data
    #get the data columns into more meaningful names
    icelength=data[:,0]
    iceldistr_x=data[:,1]
    iceldistr_y=data[:,2]
    iceldistr_z=data[:,3]
    porelength=data[:,0]
    poreldistr_x=data[:,4]
    poreldistr_y=data[:,5]
    poreldistr_z=data[:,6]

    #print some status on the screen
    print "Evaluating file no " + str(n_files) + "..."

    #-------------------------------------------------------------------
    # plot some raw data from the files to get an overview about the
    # dataset
    # -------------------------------------------------------------------
    # set marker color for current data
    color = colors[n_files % len(colors)]

    #set legendentry, the "r" denotes raw strings, good for latex
    legentry = r'id=' + str(n_files)
    #and finally plot
    ax1.semilogx(icelength, iceldistr_x/np.trapz(iceldistr_x), linestyle='--', marker='s', label=legentry)
    ax2.semilogx(icelength, iceldistr_y/np.trapz(iceldistr_y), linestyle='--', marker='s', label=legentry)
    ax3.semilogx(icelength, iceldistr_z/np.trapz(iceldistr_z), linestyle='--', marker='s', label=legentry)
    ax4.semilogx(icelength, iceldistr_x/np.trapz(iceldistr_y), linestyle='--', marker='s', label=legentry)
    ax5.semilogx(icelength, iceldistr_y/np.trapz(iceldistr_z), linestyle='--', marker='s', label=legentry)
    ax6.semilogx(icelength, iceldistr_z/np.trapz(iceldistr_y), linestyle='--', marker='s', label=legentry)
    
    #-------------------------------------------------------------------
    # if required, make some additional, fancy numerical analysis for
    # the current data, potentially plot the output in another figure
    # and store some condensed results in an additional array for
    # later plotting
    # -------------------------------------------------------------------
    #plot the evaluated data in a different figure
    #ax2.plot(corr_phi_z, linestyle='--', marker='s', label=legentry)
    #store some results in the arrays
    #squared distribution:
  #  resultx_mean.append(1/np.sum(length*ldistr_x)*np.sum(length*length*ldistr_x*ldistr_x))
  #  resulty_mean.append(1/np.sum(length*ldistr_y)*np.sum(length*length*ldistr_y*ldistr_y))
  #  resultz_mean.append(1/np.sum(length*ldistr_z)*np.sum(length*length*ldistr_x*ldistr_z))
    iceresultx_mean[n_files] = (1/np.sum(iceldistr_x)*np.sum(icelength*iceldistr_x))
    iceresulty_mean[n_files] = (1/np.sum(iceldistr_y)*np.sum(icelength*iceldistr_y))
    iceresultz_mean[n_files] = (1/np.sum(iceldistr_z)*np.sum(icelength*iceldistr_z))
    poreresultx_mean[n_files] = (1/np.sum(poreldistr_x)*np.sum(porelength*poreldistr_x))
    poreresulty_mean[n_files] = (1/np.sum(poreldistr_y)*np.sum(porelength*poreldistr_y))
    poreresultz_mean[n_files] = (1/np.sum(poreldistr_z)*np.sum(porelength*poreldistr_z))
 
  #  resultx_std.append(np.std(ldistr_x))
  #  resulty_std.append(np.std(ldistr_y))
  #  resultz_std.append(np.std(ldistr_z))

#-------------------------------------------------------------------
# make figure 1 looking nice, display it and save it as a nice
# eps-figure for the paper
# -------------------------------------------------------------------
# setting a figure title is possible, but nobody needs that

#adjust space at figure boundaries, otherwise labels might get stripped off
#set axis labels, latex is directly supported -> very nice
#set x and y range
#ax1.set_xlim([3500,5000])
#ax1.set_ylim([3500,50000])
#xTickLocator   = MultipleLocator(1000)
#ax1.xaxis.set_major_locator(xTickLocator)
#yTickLocator   = MultipleLocator(10000)
#ax1.yaxis.set_major_locator(yTickLocator)
#play around
#fig1.autofmt_xdate()
#set legend location and fontsize
fig1.subplots_adjust(left=0.2,bottom=0.15) 
ax1.set_xlabel(r'cord length distriburion in the x direction', fontsize=30)
ax1.set_ylabel(r'cord length', fontsize=30)
ax1.legend(loc='best', prop={'size':18})
ax2.set_xlabel(r'cord length distriburion in the y direction', fontsize=30)
ax2.set_ylabel(r'cord length', fontsize=30)
ax2.legend(loc='best', prop={'size':18})
ax3.set_xlabel(r'cord length distriburion in the z direction', fontsize=30)
ax3.set_ylabel(r'cord length', fontsize=30)
ax3.legend(loc='best', prop={'size':18})
fig2.subplots_adjust(left=0.2,bottom=0.15) 
ax4.set_xlabel(r'cord length distriburion in the x direction', fontsize=30)
ax4.set_ylabel(r'cord length', fontsize=30)
ax4.legend(loc='best', prop={'size':18})
fig3.subplots_adjust(left=0.2,bottom=0.15) 
ax5.set_xlabel(r'cord length distriburion in the y direction', fontsize=30)
ax5.set_ylabel(r'cord length', fontsize=30)
ax5.legend(loc='best', prop={'size':18})
fig4.subplots_adjust(left=0.2,bottom=0.15) 
ax6.set_xlabel(r'cord length distriburion in the z direction', fontsize=30)
ax6.set_ylabel(r'cord length', fontsize=30)
ax6.legend(loc='best', prop={'size':18})
#-------------------------------------------------------------------
# now turn to the great results and plot these in an additional
# figure
# -------------------------------------------------------------------
# instantiate figure 2 and plot
# make figure nice again
# ....
fig5 = plt.figure()
ax7 = fig5.add_subplot(111)

#figure_manager = plt.get_current_fig_manager()
#figure_manager.show()
# plt.get_current_fig_manager().window.geometry("+700+0")
#ax4.plot(range(len(iceresultx_mean)),iceresultx_mean/iceresultx_mean[0])
#ax4.plot(range(len(iceresulty_mean)),iceresulty_mean/iceresulty_mean[0])
#ax4.plot(range(len(iceresultz_mean)),iceresultz_mean/iceresultz_mean[0])
ax7.plot(range(len(iceresultz_mean)),2*iceresultz_mean/(iceresultx_mean+iceresulty_mean))
ax9.plot(range(len(iceresultz_mean)),2*iceresultz_mean/(iceresultx_mean+iceresulty_mean))

fig6 = plt.figure()
ax8 = fig6.add_subplot(111)

#figure_manager = plt.get_current_fig_manager()
#figure_manager.show()

# plt.get_current_fig_manager().window.geometry("+700+400")
#ax5.plot(range(len(poreresultx_mean)),poreresultx_mean/poreresultx_mean[0])
#ax5.plot(range(len(poreresulty_mean)),poreresulty_mean/poreresulty_mean[0])
#ax5.plot(range(len(poreresultz_mean)),poreresultz_mean/poreresultz_mean[0])
ax8.plot(range(len(poreresultz_mean)),2*poreresultz_mean/(poreresultx_mean+poreresulty_mean))
ax10.plot(range(len(poreresultz_mean)),2*poreresultz_mean/(poreresultx_mean+poreresulty_mean))
# and finally write result arrays to some file
of = open("great-results.txt",'w')
#write header
of.write("file id" + "\t" + "great result" + "\n")

#write data
#for n_files in range(len(evalfiles)):
  #  of.write(str(n_files) + "\t" \
 #                + str(iceresultx_mean[n_files]) + "\n")
#of.close()
for n_files in range(len(evalfiles)):
    of.write(str(n_files) + "\t" \
                 + str(iceresultx_mean[n_files]) + "\t" \
                + str(poreresultx_mean[n_files]) + "\n")
of.close()

#-------------------------------------------------------------------
# output, screen and files
# -------------------------------------------------------------------
#show everything on the screen
plt.show()
#save figures as eps for the paper
fig1.savefig('xyzdistribution.eps')
fig2.savefig('xdistribution.eps')
fig3.savefig('ydistribution.eps')
fig4.savefig('zdistribution.eps')
fig5.savefig('meanoficedistributions.eps')
fig6.savefig('meanofporedistributions.eps')
#set size settings to default again
plt.rcdefaults()
